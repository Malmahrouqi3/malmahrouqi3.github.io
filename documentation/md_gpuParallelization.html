<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SY496B9L99"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-SY496B9L99');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MFC: GPU Parallelization</title>
<meta name=”keywords” content="exascale, fluid dynamics, cfd, computational fluid dynamics, compressible, hpc, bryngelson, colonius, subgrid, multiphase, frontier, summit, el capitan, aurora, amd gpu, gpu, nvidia"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// This file is set as MATHJAX_CODEFILE in the Doxyfile. It configures how
// MathJax renders expressions in Markdown so that it is consistent with GitHub.
MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath:  [ ['$',  '$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      ignoreClass: "line" // Ignore code blocks: https://web.archive.org/web/20120430100225/http://www.mathjax.org/docs/1.1/options/tex2jax.html
    },
    "HTML-CSS": {
      fonts: ["TeX"]
    }
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="icon.ico" type="image/x-icon" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MFC
   </div>
   <div id="projectbrief">High-fidelity multiphase flow simulation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_gpuParallelization.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GPU Parallelization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md124"></a></p>
<p>MFC compiles GPU code via OpenACC and in the future OpenMP as well.</p>
<p>In order to swap between OpenACC and OpenMP, custom GPU macros are used that translate to equivalent OpenACC and OpenMP directives. FYPP is used to process the GPU macros.</p>
<p><a href="https://openacc-best-practices-guide.readthedocs.io/en/latest/01-Introduction.html">OpenACC Quick start Guide</a></p>
<p><a href="https://www.openacc.org/sites/default/files/inline-files/API%20Guide%202.7.pdf">OpenACC API Documentation</a></p>
<hr  />
<h1><a class="anchor" id="autotoc_md126"></a>
Macro API Documentation</h1>
<p>Note: Ordering is not guaranteed or stable, so use key-value pairing when using macros</p>
<h2><a class="anchor" id="autotoc_md127"></a>
Data Type Meanings</h2>
<ul>
<li>Integer is a number</li>
<li>Boolean is a pythonic boolean - Valid options: <code>True</code> or <code>False</code></li>
<li>String List is given as a comma separated list surrounding by brackets and inside quotations<ul>
<li>Ex: <code>'[hello, world, Fortran]'</code></li>
</ul>
</li>
<li>2-level string list is given as a comma separated list of string lists surrounding by brackets and inside quotations<ul>
<li>Ex: <code>'[[hello, world], [Fortran, MFC]]'</code> or <code>'[[hello]]'</code></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md128"></a>
Data Flow</h2>
<ul>
<li>Data on the GPU has a reference counter</li>
<li>When data is referred to being allocated, it means that GPU memory is allocated if it is not already present in GPU memory. If a variable is already present, the reference counter is just incremented.</li>
<li>When data is referred to being deallocated, it means that the reference counter is decremented. If the reference counter is zero, then the data is actually deallocated from GPU memory</li>
<li>When data is referred to being attached, it means that the device pointer attaches to target if it not already attached. If pointer is already attached, then the attachment counter is just incremented</li>
<li>When data is referred to being detached, it means that the attachment counter is decremented. If attachment counter is zero, then actually detached</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md130"></a>
Computation Macros</h2>
<details >
<summary >
<code>GPU_PARALLEL_LOOP</code> &ndash; <code>(Execute the following loop on the GPU in parallel)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_PARALLEL_LOOP(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>collapse</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Number of loops to combine into 1 loop    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>parallelism</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">'[gang,vector]'   </td><td class="markdownTableBodyNone">Parallelism granularity to use for this loop    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>default</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">'present'   </td><td class="markdownTableBodyNone">Implicit assumptions compiler should make    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>private</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Variables that are private to each iteration/thread    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>firstprivate</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Initialized variables that are private to each iteration/thread    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>reduction</code>   </td><td class="markdownTableBodyNone">2-level string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Variables unique to each iteration and reduced at the end    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>reductionOp</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Operator that each list of reduction will reduce with    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copy</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance, then deallocated and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyin</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance and then deallocated on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copyinReadOnly</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies readonly data to GPU and then deallocated on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyout</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>no_create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Use data in CPU memory unless data is already in GPU memory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>present</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Data that must be present in GPU memory. Increment counter on entrance, decrement on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>deviceptr</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Pointer variables that are already allocated on GPU memory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>attach</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Attaches device pointer to device targets on entrance, then detach on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Parameter Restrictions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">Restricted range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>collapse</code>   </td><td class="markdownTableBodyNone">Must be greater than 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>parallelism</code>   </td><td class="markdownTableBodyNone">Valid elements: 'gang', 'worker', 'vector', 'seq'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>default</code>   </td><td class="markdownTableBodyNone">'present' or 'none'   </td></tr>
</table>
<p><b>Additional information</b></p>
<ul>
<li>default present means that the any non-scalar data in assumed to be present on the GPU</li>
<li>default none means that the compiler should not implicitly determine the data attributes for any variable</li>
<li>reduction and reductionOp must match in length</li>
<li>With <code>reduction='[[sum1, sum2], [largest]]'</code> and <code>reductionOp='[+, max]'</code>, <code>sum1</code> and <code>sum2</code> will be the sum of sum1/sum2 in each loop iteration, and <code>largest</code> will the maximum value of <code>largest</code> all the loop iterations</li>
<li>A reduction implies a copy, so it does not need to be added for both</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_PARALLEL_LOOP(collapse=3, private=<span class="stringliteral">&#39;[tmp, r]&#39;</span>, reduction=<span class="stringliteral">&#39;[[vol, avg], [max_val]]&#39;</span>, reductionOp=<span class="stringliteral">&#39;[+, MAX]&#39;</span>)</div>
<div class="line">$:GPU_PARALLEL_LOOP(collapse=2, private=<span class="stringliteral">&#39;[sum_holder]&#39;</span>, copyin=<span class="stringliteral">&#39;[starting_sum]&#39;</span>, copyout=<span class="stringliteral">&#39;[eigenval,C]&#39;</span>)</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_LOOP</code> &ndash; <code>(Execute loop on GPU)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_LOOP(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>collapse</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Number of loops to combine into 1 loop    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>parallelism</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Parallelism granularity to use for this loop    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>data_dependency</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">'independent'-&gt; assert loop iterations are independent, 'auto-&gt;let compiler analyze dependencies    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>private</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Variables that are private to each iteration/thread    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>reduction</code>   </td><td class="markdownTableBodyNone">2-level string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Variables unique to each iteration and reduced at the end    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>reductionOp</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Operator that each list of reduction will reduce with    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Parameter Restrictions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">Restricted range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>collapse</code>   </td><td class="markdownTableBodyNone">Must be greater than 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>parallelism</code>   </td><td class="markdownTableBodyNone">Valid elements: 'gang', 'worker', 'vector', 'seq'    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>data_dependency</code>   </td><td class="markdownTableBodyNone">'auto' or 'independent'   </td></tr>
</table>
<p><b>Additional information</b></p>
<ul>
<li>Loop parallelism is most commonly <code>'[seq]'</code></li>
<li>reduction and reductionOp must match in length</li>
<li>With <code>reduction='[[sum1, sum2], [largest]]'</code> and <code>reductionOp='[+, max]'</code>, <code>sum1</code> and <code>sum2</code> will be the sum of sum1/sum2 in each loop iteration, and <code>largest</code> will the maximum value of <code>largest</code> all the loop iterations</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_LOOP(parallelism=<span class="stringliteral">&#39;[seq]&#39;</span>)</div>
<div class="line">$:GPU_LOOP(collapse=3, parallelism=<span class="stringliteral">&#39;[seq]&#39;</span>,private=<span class="stringliteral">&#39;[tmp, r]&#39;</span>)</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_PARALLEL</code> &ndash; <code>(Execute the following on the GPU in parallel)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP call directive using <code>#:call</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#:call GPU_PARALLEL(...)</span></div>
<div class="line">   {code}</div>
<div class="line"><span class="preprocessor">#:endcall GPU_PARALLEL </span></div>
</div><!-- fragment --><p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>default</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">'present'   </td><td class="markdownTableBodyNone">Implicit assumptions compiler should make    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>private</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Variables that are private to each iteration/thread    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>firstprivate</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Initialized variables that are private to each iteration/thread    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>reduction</code>   </td><td class="markdownTableBodyNone">2-level string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Variables unique to each iteration and reduced at the end    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>reductionOp</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Operator that each list of reduction will reduce with    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copy</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance, then deallocated and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyin</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance and then deallocated on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copyinReadOnly</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies readonly data to GPU and then deallocated on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyout</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>no_create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Use data in CPU memory unless data is already in GPU memory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>present</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Data that must be present in GPU memory. Increment counter on entrance, decrement on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>deviceptr</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Pointer variables that are already allocated on GPU memory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>attach</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Attaches device pointer to device targets on entrance, then detach on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Parameter Restrictions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">Restricted range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>default</code>   </td><td class="markdownTableBodyNone">'present' or 'none'   </td></tr>
</table>
<p><b>Additional information</b></p>
<ul>
<li>default present means that the any non-scalar data in assumed to be present on the GPU</li>
<li>default none means that the compiler should not implicitly determine the data attributes for any variable</li>
<li>reduction and reductionOp must match in length</li>
<li>With <code>reduction='[[sum1, sum2], [largest]]'</code> and <code>reductionOp='[+, max]'</code>, <code>sum1</code> and <code>sum2</code> will be the sum of sum1/sum2 in each loop iteration, and <code>largest</code> will the maximum value of <code>largest</code> all the loop iterations</li>
<li>A reduction implies a copy, so it does not need to be added for both</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#:call GPU_PARALLEL()</span></div>
<div class="line">     {code}</div>
<div class="line">     ...</div>
<div class="line">#:endcall GPU_PARALLEL</div>
<div class="line"><span class="preprocessor">#:call GPU_PARALLEL(create=&#39;[pixel_arr]&#39;, copyin=&#39;[initial_index]&#39;)</span></div>
<div class="line">     {code}</div>
<div class="line">     ...</div>
<div class="line">#:endcall</div>
</div><!-- fragment --><p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md132"></a>
Data Control Macros</h2>
<details >
<summary >
<code>GPU_DATA</code> &ndash; <code>(Make data accessible on GPU in specified region)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP call directive using <code>#:call</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#:call GPU_DATA(...)</span></div>
<div class="line">   {code}</div>
<div class="line"><span class="preprocessor">#:endcall GPU_DATA </span></div>
</div><!-- fragment --><p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>code</code>   </td><td class="markdownTableBodyNone">code   </td><td class="markdownTableBodyNone">Required   </td><td class="markdownTableBodyNone">Region of code where defined data is accessible    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copy</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies variable to GPU on entrance, then deallocated and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyin</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance and then deallocated on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copyinReadOnly</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies a readonly variable to GPU and then deallocated on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyout</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>no_create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Use data in CPU memory unless data is already in GPU memory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>present</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Data that must be present in GPU memory. Increment counter on entrance, decrement on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>deviceptr</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Pointer variables that are already allocated on GPU memory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>attach</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Attaches device pointer to device targets on entrance, then detach on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>default</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Implicit assumptions compiler should make    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Parameter Restrictions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">Restricted range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>code</code>   </td><td class="markdownTableBodyNone">Do not assign it manually with key-value pairing   </td></tr>
</table>
<p><b>Example</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#:call GPU_DATA(copy=&#39;[pixel_arr]&#39;, copyin=&#39;[starting_pixels, initial_index]&#39;,attach=&#39;[p_real, p_cmplx, p_fltr_cmplx]&#39;)</span></div>
<div class="line">     {code}</div>
<div class="line">     ...</div>
<div class="line">#:endcall GPU_DATA</div>
<div class="line"><span class="preprocessor">#:call GPU_DATA(create=&#39;[pixel_arr]&#39;, copyin=&#39;[initial_index]&#39;)</span></div>
<div class="line">     {code}</div>
<div class="line">     ...</div>
<div class="line">#:endcall</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_ENTER_DATA</code> &ndash; <code>(Allocate/move data to GPU until matching GPU_EXIT_DATA or program termination)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_ENTER_DATA(...)</code></p>
<p><b>Parameter</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyin</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copyinReadOnly</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies a readonly variable to GPU on entrance    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>attach</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Attaches device pointer to device targets on entrance    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_ENTER_DATA(copyin=<span class="stringliteral">&#39;[pixels_arr]&#39;</span>, copyinReadOnly=<span class="stringliteral">&#39;[starting_pixels, initial_index]&#39;</span>)</div>
<div class="line">$:GPU_ENTER_DATA(create=<span class="stringliteral">&#39;[bc_buffers(1:num_dims, -1:1)]&#39;</span>, copyin=<span class="stringliteral">&#39;[initial_index]&#39;</span>)</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_EXIT_DATA</code> &ndash; <code>(Deallocate/move data from GPU created by GPU_ENTER_DATA)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_EXIT_DATA(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyout</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Deallocates and copies data from GPU to CPU on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>delete</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Deallocates data on GPU on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>detach</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Detach device pointer from device targets on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_EXIT_DATA(copyout=<span class="stringliteral">&#39;[pixels_arr]&#39;</span>, delete=<span class="stringliteral">&#39;[starting_pixels, initial_index]&#39;</span>)</div>
<div class="line">$:GPU_EXIT_DATA(delete=<span class="stringliteral">&#39;[bc_buffers(1:num_dims, -1:1)]&#39;</span>, copyout=<span class="stringliteral">&#39;[initial_index]&#39;</span>)</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_DECLARE</code> &ndash; <code>(Allocate module variables on GPU or for implicit data region )</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_DECLARE(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copy</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance, then deallocated and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copyin</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies data to GPU on entrance and then deallocated on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>copyinReadOnly</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates and copies a readonly variable to GPU and then deallocated on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>copyout</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates and copies to CPU on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>create</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Allocates data on GPU on entrance and then deallocates on exit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>present</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Data that must be present in GPU memory. Increment counter on entrance, decrement on exit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>deviceptr</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Pointer variables that are already allocated on GPU memory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>link</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Declare global link, and only allocate when variable used in data clause.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Additional information</b></p>
<ul>
<li>An implicit data region is created at the start of each procedure and ends after the last executable statement in that procedure.</li>
<li>Use only create, copyin, device_resident or link clauses for module variables</li>
<li>GPU_DECLARE exit is the end of the implicit data region</li>
<li>Link is useful for large global static data objects</li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_DECLARE(create=<span class="stringliteral">&#39;[x_cb,y_cb,z_cb,x_cc,y_cc,z_cc,dx,dy,dz,dt,m,n,p]&#39;</span>)</div>
<div class="line">$:GPU_DECLARE(create=<span class="stringliteral">&#39;[x_cb,y_cb,z_cb]&#39;</span>, copyin=<span class="stringliteral">&#39;[x_cc,y_cc,z_cc]&#39;</span>, link=<span class="stringliteral">&#39;[dx,dy,dz,dt,m,n,p]&#39;</span>)</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_UPDATE</code> &ndash; <code>(Updates data from CPU to GPU or GPU to CPU)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_UPDATE(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>host</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Updates data from GPU to CPU    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>device</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Updates data from CPU to GPU    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_UPDATE(host=<span class="stringliteral">&#39;[arr1, arr2]&#39;</span>)</div>
<div class="line">$:GPU_UPDATE(host=<span class="stringliteral">&#39;[updated_gpu_val]&#39;</span>, device=<span class="stringliteral">&#39;[updated_cpu_val]&#39;</span>)</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_HOST_DATA</code> &ndash; <code>(Make GPU memory address available on CPU)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP call directive using <code>#:call</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#:call GPU_HOST_DATA(...)</span></div>
<div class="line">   {code}</div>
<div class="line"><span class="preprocessor">#:endcall GPU_HOST_DATA </span></div>
</div><!-- fragment --><p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>code</code>   </td><td class="markdownTableBodyNone">code   </td><td class="markdownTableBodyNone">Required   </td><td class="markdownTableBodyNone">Region of code where GPU memory addresses is accessible    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>use_device</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Use GPU memory address of variable instead of CPU memory address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Parameter Restrictions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">Restricted range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>code</code>   </td><td class="markdownTableBodyNone">Do not assign it manually with key-value pairing   </td></tr>
</table>
<p><b>Example</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#:call GPU_HOST_DATA(use_device=&#39;[addr1, addr2]&#39;)</span></div>
<div class="line">     {code}</div>
<div class="line">     ...</div>
<div class="line">#:endcall GPU_HOST_DATA</div>
<div class="line"><span class="preprocessor">#:call GPU_HOST_DATA(use_device=&#39;[display_arr]&#39;)</span></div>
<div class="line">     {code}</div>
<div class="line">     ...</div>
<div class="line"> #:endcall</div>
</div><!-- fragment --><p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md134"></a>
Synchronization Macros</h2>
<details >
<summary >
<code>GPU_WAIT</code> &ndash; <code>(Makes CPU wait for async GPU activities)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_WAIT(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_WAIT()</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_ATOMIC</code> &ndash; <code>(Do an atomic operation on the GPU)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_ATOMIC(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>atomic</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">Required   </td><td class="markdownTableBodyNone">Which atomic operation is performed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Parameter Restrictions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">Restricted range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>atomic</code>   </td><td class="markdownTableBodyNone">'read', 'write', 'update', or 'capture'   </td></tr>
</table>
<p><b>Additional information</b></p>
<ul>
<li>read atomic is reading in a value<ul>
<li>Ex: <code>v=x</code></li>
</ul>
</li>
<li>write atomic is writing a value to a variable<ul>
<li>Ex:<code>x=square(tmp)</code></li>
</ul>
</li>
<li>update atomic is updating a variable in-place<ul>
<li>Ex:<code>x= x .and. 1</code></li>
</ul>
</li>
<li><p class="startli">Capture is a pair of read/write/update operations with one dependent on the other</p><ul>
<li>Ex:</li>
</ul>
<div class="fragment"><div class="line">x=x .and. 1</div>
<div class="line">v=x</div>
</div><!-- fragment --></li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_ATOMIC(atomic=<span class="stringliteral">&#39;update&#39;</span>)</div>
<div class="line">x = square(x)</div>
<div class="line">$:GPU_ATOMIC(atomic=<span class="stringliteral">&#39;capture&#39;</span>)</div>
<div class="line">x = square(x)</div>
<div class="line">v = x</div>
</div><!-- fragment --><p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md136"></a>
Miscellaneous Macros</h2>
<details >
<summary >
<code>GPU_ROUTINE</code> &ndash; <code>(Compile a procedure for the GPU)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_ROUTINE(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>function_name</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Name of subroutine/function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>parallelism</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">Parallelism granularity to use for this routine    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>nohost</code>   </td><td class="markdownTableBodyNone">boolean   </td><td class="markdownTableBodyNone">False   </td><td class="markdownTableBodyNone">Do not compile procedure code for CPU    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>cray_inline</code>   </td><td class="markdownTableBodyNone">boolean   </td><td class="markdownTableBodyNone">False   </td><td class="markdownTableBodyNone">Inline procedure on cray compiler    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Parameter Restrictions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">Restricted range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>parallelism</code>   </td><td class="markdownTableBodyNone">Valid elements: 'gang', 'worker', 'vector', 'seq'   </td></tr>
</table>
<p><b>Additional information</b></p>
<ul>
<li>Function name only needs to be given when cray_inline is True</li>
<li>Future capability is to parse function header for function name</li>
<li>Routine parallelism is most commonly <code>'[seq]'</code></li>
</ul>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_ROUTINE(parallelism=<span class="stringliteral">&#39;[seq]&#39;</span>)</div>
<div class="line">$:GPU_ROUTINE(function_name=<span class="stringliteral">&#39;s_matmult&#39;</span>, parallelism=<span class="stringliteral">&#39;[seq]&#39;</span>, cray_inline=<span class="keyword">True</span>)</div>
</div><!-- fragment --><p></p>
</details>
<details >
<summary >
<code>GPU_CACHE</code> &ndash; <code>(Data to be cache in software-managed cache)</code></summary>
<p></p>
<p><b>Macro Invocation</b></p>
<p>Uses FYPP eval directive using <code>$:</code></p>
<p><code>$:GPU_CACHE(...)</code></p>
<p><b>Parameters</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">data type   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>cache</code>   </td><td class="markdownTableBodyNone">string list   </td><td class="markdownTableBodyNone">Required   </td><td class="markdownTableBodyNone">Data that should to stored in cache    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>extraAccArgs</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">String of any extra arguments added to the OpenACC directive   </td></tr>
</table>
<p><b>Example</b></p>
<div class="fragment"><div class="line">$:GPU_CACHE(cache=<span class="stringliteral">&#39;[pixels_arr]&#39;</span>)</div>
</div><!-- fragment --><p></p>
</details>
<hr  />
<h1><a class="anchor" id="autotoc_md138"></a>
Debugging Tools and Tips for GPUs</h1>
<h2><a class="anchor" id="autotoc_md139"></a>
Compiler agnostic tools</h2>
<h2><a class="anchor" id="autotoc_md140"></a>
OpenMP tools</h2>
<div class="fragment"><div class="line">OMP_DISPLAY_ENV=true | false | verbose</div>
</div><!-- fragment --><ul>
<li>Prints out the internal control values and environment variables at the beginning of the program if <code>true</code> or <code>verbose</code></li>
<li><code>verbose</code> will also print out vendor-specific internal control values and environment variables</li>
</ul>
<div class="fragment"><div class="line">OMP_TARGET_OFFLOAD = MANDATORY | DISABLED | DEFAULT</div>
</div><!-- fragment --><ul>
<li>Quick way to turn off off-load (<code>DISABLED</code>) or make it abort if a GPU isn't found (<code>MANDATORY</code>)</li>
<li>Great first test: does the problem disappear when you drop back to the CPU?</li>
</ul>
<div class="fragment"><div class="line">OMP_THREAD_LIMIT=&lt;positive_integer&gt;</div>
</div><!-- fragment --><ul>
<li>Sets the maximum number of OpenMP threads to use in a contention group</li>
<li>Might be useful in checking for issues with contention or race conditions</li>
</ul>
<div class="fragment"><div class="line">OMP_DISPLAY_AFFINITY=TRUE</div>
</div><!-- fragment --><ul>
<li>Will display affinity bindings for each OpenMP thread, containing hostname, process identifier, OS thread identifier, OpenMP thread identifier, and affinity binding.</li>
</ul>
<h2><a class="anchor" id="autotoc_md141"></a>
Cray Compiler Tools</h2>
<h3><a class="anchor" id="autotoc_md142"></a>
Cray General Options</h3>
<div class="fragment"><div class="line">CRAY_ACC_DEBUG: 0 (off), 1, 2, 3 (very noisy)</div>
</div><!-- fragment --><ul>
<li>Dumps a time-stamped log line (<code>ACC: ...</code>) for every allocation, data transfer, kernel launch, wait, etc. Great first stop when "nothing seems to run on the GPU".</li>
<li>Outputs on STDERR by default. Can be changed by setting <code>CRAY_ACC_DEBUG_FILE</code>.<ul>
<li>Recognizes <code>stderr</code>, <code>stdout</code>, and <code>process</code>.</li>
<li><code>process</code> automatically generates a new file based on <code>pid</code> (each MPI process will have a different file)</li>
</ul>
</li>
<li>While this environment variable specifies ACC, it can be used for both OpenACC and OpenMP</li>
</ul>
<div class="fragment"><div class="line">CRAY_ACC_FORCE_EARLY_INIT=1</div>
</div><!-- fragment --><ul>
<li>Force full GPU initialization at program start so you can see start-up hangs immediately</li>
<li>Default behavior without an environment variable is to defer initialization on first use</li>
<li>Device initialization includes initializing the GPU vendor’s low-level device runtime library (e.g., libcuda for NVIDIA GPUs) and establishing all necessary software contexts for interacting with the device</li>
</ul>
<h3><a class="anchor" id="autotoc_md143"></a>
Cray OpenACC Options</h3>
<div class="fragment"><div class="line">CRAY_ACC_PRESENT_DUMP_SAVE_NAMES=1</div>
</div><!-- fragment --><ul>
<li>Will cause <code>acc_present_dump()</code> to output variable names and file locations in addition to variable mappings</li>
<li>Add <code>acc_present_dump()</code> around hotspots to help find problems with data movements<ul>
<li>Helps more if adding <code>CRAY_ACC_DEBUG</code> environment variable</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md144"></a>
NVHPC Compiler Options</h2>
<h3><a class="anchor" id="autotoc_md145"></a>
NVHPC General Options</h3>
<div class="fragment"><div class="line">STATIC_RANDOM_SEED=1</div>
</div><!-- fragment --><ul>
<li>Forces the seed returned by <code>RANDOM_SEED</code> to be constant, so it generates the same sequence of random numbers</li>
<li>Useful for testing issues with randomized data</li>
</ul>
<div class="fragment"><div class="line">NVCOMPILER_TERM=option[,option]</div>
</div><!-- fragment --><ul>
<li><code>[no]debug</code>: Enables/disables just-in-time debugging (debugging invoked on error)</li>
<li><code>[no]trace</code>: Enables/disables stack traceback on error</li>
</ul>
<h3><a class="anchor" id="autotoc_md146"></a>
NVHPC OpenACC Options</h3>
<div class="fragment"><div class="line">NVCOMPILER_ACC_NOTIFY= &lt;bitmask&gt;</div>
</div><!-- fragment --><ul>
<li>Assign the environment variable to a bitmask to print out information to stderr for the following<ul>
<li>kernel launches: 1</li>
<li>data transfers: 2</li>
<li>region entry/exit: 4</li>
<li>wait operation of synchronizations with the device: 8</li>
<li>device memory allocations and deallocations: 16</li>
</ul>
</li>
<li>1 (kernels only) is the usual first step.3 (kernels + copies) is great for "why is it so slow?"</li>
</ul>
<div class="fragment"><div class="line">NVCOMPILER_ACC_TIME=1</div>
</div><!-- fragment --><ul>
<li>Lightweight profiler</li>
<li>prints a tidy end-of-run table with per-region and per-kernel times and bytes moved</li>
<li>Do not use with CUDA profiler at the same time</li>
</ul>
<div class="fragment"><div class="line">NVCOMPILER_ACC_DEBUG=1</div>
</div><!-- fragment --><ul>
<li>Spews everything the runtime sees: host/device addresses, mapping events, present-table look-ups, etc.</li>
<li>Great for "partially present" or "pointer went missing" errors.</li>
<li><a href="https://docs.nvidia.com/hpc-sdk/archive/20.9/pdf/hpc209openacc_gs.pdf">Doc for NVCOMPILER_ACC_DEBUG</a><ul>
<li>Ctrl+F for <code>NVCOMPILER_ACC_DEBUG</code></li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md147"></a>
NVHPC OpenMP Options</h3>
<div class="fragment"><div class="line">LIBOMPTARGET_PROFILE=run.json</div>
</div><!-- fragment --><ul>
<li>Emits a Chrome-trace (JSON) timeline you can open in chrome://tracing or Speedscope</li>
<li>Great lightweight profiler when Nsight is overkill.</li>
<li>Granularity in µs via <code>LIBOMPTARGET_PROFILE_GRANULARITY</code> (default 500).</li>
</ul>
<div class="fragment"><div class="line">LIBOMPTARGET_INFO=&lt;bitmask&gt;</div>
</div><!-- fragment --><ul>
<li>Prints out different types of runtime information</li>
<li>Human-readable log of data-mapping inserts/updates, kernel launches, copies, waits.</li>
<li>Perfect first stop for "why is nothing copied?"</li>
<li>Flags<ul>
<li>Print all data arguments upon entering an OpenMP device kernel: 0x01</li>
<li>Indicate when a mapped address already exists in the device mapping table: 0x02</li>
<li>Dump the contents of the device pointer map at kernel exit: 0x04</li>
<li>Indicate when an entry is changed in the device mapping table: 0x08</li>
<li>Print OpenMP kernel information from device plugins: 0x10</li>
<li>Indicate when data is copied to and from the device: 0x20</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">LIBOMPTARGET_DEBUG=1</div>
</div><!-- fragment --><ul>
<li>Developer-level trace (host-side)</li>
<li>Much noisier than <code>INFO</code></li>
<li>Only works if the runtime was built with <code>-DOMPTARGET_DEBUG</code>.</li>
</ul>
<div class="fragment"><div class="line">LIBOMPTARGET_JIT_OPT_LEVEL=-O{0,1,2,3}</div>
</div><!-- fragment --><ul>
<li>This environment variable can be used to change the optimization pipeline used to optimize the embedded device code as part of the device JIT.</li>
<li>The value corresponds to the <code>-O{0,1,2,3}</code> command line argument passed to clang.</li>
</ul>
<div class="fragment"><div class="line">LIBOMPTARGET_JIT_SKIP_OPT=1</div>
</div><!-- fragment --><ul>
<li>This environment variable can be used to skip the optimization pipeline during JIT compilation.</li>
<li>If set, the image will only be passed through the backend.</li>
<li>The backend is invoked with the <code>LIBOMPTARGET_JIT_OPT_LEVEL</code> flag.</li>
</ul>
<h2><a class="anchor" id="autotoc_md148"></a>
Compiler Documentation</h2>
<ul>
<li><a href="https://cpe.ext.hpe.com/docs/24.11/cce/man7/intro_openmp.7.html#environment-variables">Cray &amp; OpenMP Docs</a></li>
<li><a href="https://cpe.ext.hpe.com/docs/24.11/cce/man7/intro_openacc.7.html#environment-variables">Cray &amp; OpenACC Docs</a></li>
<li><a href="https://docs.nvidia.com/hpc-sdk/compilers/hpc-compilers-user-guide/index.html?highlight=NVCOMPILER_#environment-variables">NVHPC &amp; OpenACC Docs</a></li>
<li><a href="https://docs.nvidia.com/hpc-sdk/compilers/hpc-compilers-user-guide/index.html?highlight=NVCOMPILER_#id2">NVHPC &amp; OpenMP Docs</a></li>
<li><a href="https://openmp.llvm.org/design/Runtimes.html">LLVM &amp; OpenMP Docs</a><ul>
<li>NVHPC is built on top of LLVM</li>
</ul>
</li>
<li><a href="https://www.openmp.org/spec-html/5.1/openmp.html">OpenMP Docs</a></li>
<li><a href="https://www.openacc.org/sites/default/files/inline-files/OpenACC.2.7.pdf">OpenACC Docs</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
